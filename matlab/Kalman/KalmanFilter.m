function [Output, CovarianceMatrix_Refresh] = KalmanFilter(PreviousState, ObservedValue, TimePeriod, ...
        CovarianceMatrix, ...
        NoiseMatrix, ObservingVariance, useAcc)
    %% ************************************************************
    % This function operates kalman filering once, because during
    % the system processing, and based on the kalman filter theory,
    % next state always based on the current state and observed
    % value. So, in order to simulate the real processing as much
    % as possibl, this function should be called iterative in main
    % program
    % -- Input parameters
    % @PreviouseState, state that need to traced, it could includes
    %                  position, velocity, accelerate and other data
    %                  that could used to describe a target's state
    % @ObservedValue,  It has the same parameters as PreviouseState.
    %                  If PreviouseState includes position, position
    %                  also has to included in ObservedValue. This
    %                  parameter generated by observing.
    % @TimePeriod,     Time period, which is necessary in this system
    %                  because distance and instantaneous velociy are
    %                  both related to time.
    % @ConvarianceMatrix, A covariance matrix that limites the state
    %                  range.
    % @NoiseMatrix,    Optimization parameter, in order to achieve
    %                  a better performance this parameter could
    %                  be adjusted and modified.
    % @ObservingVariance, Optimization parameter, this parameter
    %                  reflects the confidence of observed value.
    %                  The smaller the value is, the lower the
    %                  confidence of observed value.
    % -- Output parameters
    % @ Output,        Target state after filted.
    % @ CovarianceMatrix_Refresh, refreshed covariance matrix
    % *************************************************************
    dT = TimePeriod;

    if (useAcc)
        %% With accelerate
        A = [1, 0, 0, dT, 0, 0, 0.5 * dT ^ 2, 0, 0; ...
                 0, 1, 0, 0, dT, 0, 0, 0.5 * dT ^ 2, 0; ...
                 0, 0, 1, 0, 0, dT, 0, 0, 0.5 * dT ^ 2; ...
                 0, 0, 0, 1, 0, 0, dT, 0, 0; ...
                 0, 0, 0, 0, 1, 0, 0, dT, 0; ...
                 0, 0, 0, 0, 0, 1, 0, 0, dT; ...
                 0, 0, 0, 0, 0, 0, 1 0, 0; ...
                 0, 0, 0, 0, 0, 0, 0, 1, 0; ...
                 0, 0, 0, 0, 0, 0, 0, 0, 1]; % -- State transforming matrix
        H = [1, 0, 0, 0, 0, 0, 0, 0, 0;
             0, 1, 0, 0, 0, 0, 0, 0, 0;
             0, 0, 1, 0, 0, 0, 0, 0, 0];

    else
        %% Without accelerate
        A = [1, 0, 0, dT, 0, 0; ...
                 0, 1, 0, 0, dT, 0; ...
                 0, 0, 1, 0, 0, dT; ...
                 0, 0, 0, 1, 0, 0; ...
                 0, 0, 0, 0, 1, 0; ...
                 0, 0, 0, 0, 0, 1];
        H = [1, 0, 0, 0, 0, 0;
             0, 1, 0, 0, 0, 0;
             0, 0, 1, 0, 0, 0];
    end

    % B = [0.5 * dT ^ 2, 0, 0; ...
    % 0, 0.5 * dT ^ 2, 0; ...
    % 0, 0, 0.5 * dT ^ 2; ...
    % dT, 0, 0; ...
    % 0, dT, 0; ...
    % 0, 0, dT];
    % g = [0; 0; 0]; % Acclerate set to 0.

    I = eye(6); % % If use acclerate, the number should be 9

    %% Main part
    %Prediction = A*PreviousState + B*g;
    Prediction = A * PreviousState;
    P_refresh = A * CovarianceMatrix * A' + NoiseMatrix;

    if (ObservedValue ~= 0)
        K = (P_refresh * H') / (H * P_refresh * H' + ObservingVariance);
        Output = Prediction + K * (ObservedValue - H * Prediction);
        CovarianceMatrix_Refresh = (I - K * H) * P_refresh;
    else
        Output = Prediction;
        CovarianceMatrix_Refresh = P_refresh;
    end

end
