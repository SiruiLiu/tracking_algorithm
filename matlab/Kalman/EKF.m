function [Output, CovarianceMatrix_Refreshed] = EKF(PreviousState, ...
        ObservedValue, TimePeriod, ...
        StateTransMat, CovarianceMatrix, H, ...
        ProcessVarMat, ObservingVarMat, useRandomAcc)

    %% ************************************************************
    % This function operates kalman filering once, because during
    % the system processing, and based on the kalman filter theory,
    % next state always based on the current state and observed
    % value. So, in order to simulate the real processing as much
    % as possibl, this function should be called iterative in main
    % program
    % -- Input parameters
    % @PreviouseState, state that need to traced, it could includes
    %                  position, velocity, accelerate and other data
    %                  that could used to describe a target's state
    % @ObservedValue,  It has the same parameters as PreviouseState.
    %                  If PreviouseState includes position, position
    %                  also has to included in ObservedValue. This
    %                  parameter generated by observing.
    % @TimePeriod,     Time period, which is necessary in this system
    %                  because distance and instantaneous velociy are
    %                  both related to time.
    % @ConvarianceMatrix, A covariance matrix that limites the state
    %                  range.
    % @NoiseMatrix,    Optimization parameter, in order to achieve
    %                  a better performance this parameter could
    %                  be adjusted and modified.
    % @ObservingVariance, Optimization parameter, this parameter
    %                  reflects the confidence of observed value.
    %                  The smaller the value is, the lower the
    %                  confidence of observed value.
    % -- Output parameters
    % @ Output,        Target state after filted.
    % @ CovarianceMatrix_Refreshed, refreshed covariance matrix
    % *************************************************************
    dT = TimePeriod;
    I = eye(length(PreviousState));
    % B = [0.5 * dT ^ 2, 0, 0; ...
    % 0, 0.5 * dT ^ 2, 0; ...
    % 0, 0, 0.5 * dT ^ 2; ...
    % dT, 0, 0; ...
    % 0, dT, 0; ...
    % 0, 0, dT];
    % g = [0; 0; 0]; % Acclerate set to 0.

    %% Main part
    %Prediction = A*PreviousState + B*g;
    if (useRandomAcc)
        Prediction = state_transition(PreviousState, dT);
    else
        Prediction = StateTransMat * PreviousState;
    end

    P_refresh = StateTransMat * CovarianceMatrix * StateTransMat' + ProcessVarMat;

    if (ObservedValue ~= 0)
        K = (P_refresh * H') / (H * P_refresh * H' + ObservingVarMat);
        Output = Prediction + K * (ObservedValue - H * Prediction);
        CovarianceMatrix_Refreshed = (I - K * H) * P_refresh;
    else
        Output = Prediction;
        CovarianceMatrix_Refreshed = P_refresh;
    end

end

function [pred] = state_transition(state, d_t)
    pos = state(1:3);
    vel = state(4:6);
    a = randn(3, 1) * 1;
    pos_pred = pos + vel * d_t + 0.5 * a * d_t ^ 2;
    vel_pred = vel + a * d_t;
    pred = [pos_pred; vel_pred];
end
